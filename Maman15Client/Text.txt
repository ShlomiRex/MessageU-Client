	/*
	while (true) {
		InteractiveMenu::show_menu(myUsername, &myClientId);

		ClientChoices choice = InteractiveMenu::get_choice();
		Client client(ip, port, CLIENT_VERSION);

		try {
			if (choice == ClientChoices::registerUser) {
				myUsername = InteractiveMenu::readUsername();
				client.connect();
				client.registerUser(myUsername, myClientId);
			}
			else if (choice == ClientChoices::reqClientList) {
				client.connect();
				client.getClients(&savedUsers);
			}
			else if (choice == ClientChoices::reqPublicKey) {
				InteractiveMenu::show_users(&savedUsers);
				InteractiveMenu::getClientId(myClientId, &savedUsers);
				client.connect();
				client.getPublicKey(myClientId, savedPubKey);
				pubKeySaved = true;
			}
			else if (choice == ClientChoices::sendMessage) {
				//TODO: Impliment
				LOG("Not yet implimented");
			}
			else if (choice == ClientChoices::sendReqSymmetricKey) {
				FileManager::getSavedClientId(myClientId);
					
				ClientId dest_clientId;
				InteractiveMenu::show_users(&savedUsers);
				InteractiveMenu::getClientId(dest_clientId, &savedUsers);
				client.connect();
				client.getSymKey(myClientId, dest_clientId);
			}
			else if (choice == ClientChoices::sendFile) {
				//TODO: Impliment as bonous
				LOG("Not yet implimented");
			}
			else if (choice == ClientChoices::reqPullWaitingMessages) {
				FileManager::getSavedClientId(myClientId);

				client.connect();
				client.pullMessages(myClientId, savedUsers);
			}
			else if (choice == ClientChoices::sendSymmetricKey) {
				//Get dest client
				ClientId dest_clientId;
				InteractiveMenu::show_users(&savedUsers);
				InteractiveMenu::getClientId(dest_clientId, &savedUsers);

				string username = InteractiveMenu::resolveUsername(dest_clientId, &savedUsers);
				if (username.size() == 0) {
					LOG("You must first get public key. Do you want to automatically resolve public key of '" << username << "'? [Y/n]");
					stringstream ss;
					ss << "You must first get public key. Do you want to automatically resolve public key of '" << username << "'?";
					bool yesChoice = InteractiveMenu::yesNoChoice(ss.str());

					if (yesChoice) {
						client.connect();
						client.getPublicKey(myClientId, savedPubKey);
						pubKeySaved = true;
					}
					else {
						LOG("Please get public key manually.");
					}
				}
				else {

				}

				//Get destination client public key
				if (pubKeySaved) {

					/*
					SecureChannel sec;
					memcpy(sec.user.client_id, dest_clientId, S_CLIENT_ID);

					for (const auto& x : savedUsers) {
						if (strncmp(x.client_id, dest_clientId, S_CLIENT_ID) == 0) {
							strncpy_s(sec.user.username, x.username, S_USERNAME);
							break;
						}
					}
					*/

					//Generate new symmetric key
					SymmetricKey symkey;
					SymmetricCrypto::generateKey(symkey);

					//Create 
					//SecureChannel sec;
					//memcpy(sec.user.client_id, dest_clientId, S_CLIENT_ID);


					client.connect();
					client.sendSymKey(myClientId, symkey, dest_clientId, savedPubKey);
				}
				else {
					
				}
			}
			else if (choice == Menu::ClientChoices::exitProgram) {
				break;
			}
			else {
				LOG("ERROR: Unknown client choice: " << static_cast<int>(choice));
			}
		}
		catch (EmptyClientsList& e) {
			LOG(e.what());
			bool yesChoice = InteractiveMenu::yesNoChoice("Do you want me to fetch users automatically? (request #20)");
			if (yesChoice) {
				client.connect();
				client.getClients(&savedUsers);
			}
			else {
				LOG("Returning to main menu.");
			}
		}
		catch (exception& e) {
			LOG(e.what());
		}
		cout << "\n\n\n";
	}
	*/